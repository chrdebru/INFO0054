<!DOCTYPE html>
<html lang="fr">

<head>
    <title>Programmation Fonctionnelle. Chapitre 06: Récursivité structurelle</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="shower/themes/material/styles/styles.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism.min.css"
        integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        .shower {
            --slide-ratio: calc(4 / 3);
            --color-key: lightblue;
            line-height: 1.3;
        }

        @page {
           size: 1024px 768px;
           border: 1px solid black;
        }
        
        .slide {
            padding-left: 45px;
            padding-right: 30px;
            padding-top: 30px;
        }

        .slide ul,
        .slide ol {
            margin-left: 30px;
        }

        mjx-container[jax="CHTML"] {
            color: blue;
        }

        .slide pre code {
            line-height: 1.5;
        }

        pre[class*=language-] {
            padding: 0px 5px;
            overflow: hidden;
        }

        pre[class*=language-].input {
            background-color: lightgoldenrodyellow;
            margin-bottom: 0px;
        }

        pre[class*=language-].output {
            background-color: ivory;
            margin-top: 0px;
        }

        pre[class*=language-].error {
            background-color: pink;
            margin-top: 0px;
        }

        .specification {
            border: 2px solid blue;
            padding: 5px; 
            color: red;
        }
    </style>
</head>

<body class="shower list">

    <header class="caption">
        <h1>Chapitre 06: Récursivité structurelle</h1>
        <p><sub>Cette présentation est basée sur les transparents de Prof. Dr. Em. Pascal Gribomont.</sub></p>
    </header>

    <section class="slide">
        <h2>Chapitre 06: Récursivité structurelle</h2>
        <h3>Principe de la récursivité structurelle</h3>
    
        <p>Le système "accepte" toute définition récursive syntaxiquement correcte, même si la procédure associée donne lieu
            à des calculs infinis. L'utilisateur doit savoir si, dans un domaine donné, le calcul se terminera toujours.
            Pour les domaines usuels, des schémas existent qui garantissent la terminaison.</p>
        <p>Cas particulier : les schémas <em>structurels</em>, basés sur la manière dont les objets du domaine de calcul sont
            construits.</p>
        <p>Le processus d'évaluation réduit le calcul de $f(v)$ au calcul de $f(v_1),\ldots,f(v_n)$ où les $v_i$ sont des composants
            (immédiats) de $v$. Cette technique est sûre tant que l'on se limite aux domaines dont les objets ont un nombre
            fini de <em>composants (immédiats ou non)</em>, clairement identifiés.</p>
    </section>

    <section class="slide">
        <h2>Chapitre 06: Récursivité structurelle</h2>
        <h3>Principe de la récursivité structurelle</h3>

        <p>Domaines usuels de base :</p>
        <ul>
            <li>Nombres naturels</li>
            <li>Listes</li>
            <li>Expressions symboliques</li>
        </ul>
        <p>En plus : domaines dérivés des précédents, surtout par produit cartésien.</p>
    </section>

    <section class="slide">
        <h3>Récursivité structurelle : les naturels I</h3>
    
        <div class="columns two">
            <div>
                <p>Conceptuellement, les naturels sont construits à partir de $0$ et de la fonction successeur $succ$. 
                    $0$ n'a pas de composant (objet de base) ; $16$ est le seul composant immédiat de $17 = succ(16)$.</p>
                <p>Schéma de base : </p>
                <pre class=""><code class="language-scheme">(define F
  (lambda (n u)
    (if (zero? n)
        (G u)
        (H (F (- n 1) (K n u))
            n
            u))))</code></pre>
            </div>
            <div>
                <p>Les fonctions <code>G</code>, <code>H</code> et <code>K</code> sont supposées déjà définies.</p>
                <p><code>u</code> représente une suite de 0, 1 ou plusieurs arguments ; (une suite de 0 argument se réduit à
                    rien !).</p>
                <p>Le calcul de <code class="language-scheme">(F 0 u)</code> n'implique pas d'appel récursif.</p>
                <p>Le calcul de <code class="language-scheme">(F n u)</code> implique celui de <code
                        class="language-scheme">(F (- n 1) (K n u))</code> si <code>n</code> n'est pas nul.</p>
            </div>
        </div>
    </section>

    <section class="slide">
        <h3>Récursivité structurelle : les naturels II</h3>
    
        <p>Schéma de base <em>simplifié</em> : </p>
        <p>Le cas où <code>u</code> est absent suffit souvent :</p>
        <pre class=""><code class="language-scheme">(define F
  (lambda (n)
    (if (zero? n)
        c ; le numéro n, une constante, ...
        (H (F (- n 1))
            n))))</code></pre>
    </section>

    <section class="slide">
        <h3>Récursivité structurelle : les naturels III</h3>
    
        <p>Exemple : </p>

        <div class="columns two">
            <div>
                <pre class=""><code class="language-scheme">(define harmonic-sum
  (lambda (n)
    (if (zero? n)
        0
        (+ (/ 1.0 n) 
           (harmonic-sum (- n 1))))))</code></pre>
           <pre class="input next"><code class="language-scheme">&gt; (harmonic-sum 5)</code></pre>
           <pre class="output next"><code class="language-">2.283333333333333</code></pre>
        </div>
           <div>
                <pre class="next"><code class="language-scheme">(define F
  (lambda (n)
    (if (zero? n)
        c
        (H (F (- n 1))
           n))))</code></pre> 
                <pre class="next"><code class="language-scheme">(define c 0)</code></pre>       
                <pre class="next"><code class="language-scheme">(define H 
  (lambda (x n) 
    (+ (/ 1.0 n) x)))</code></pre>       
            </div>
        </div>

        <br />
        <p class="next note">Remarque : nous discuterons du <em>tail recursion</em> en plus de détail plus tard dans ce cours.</p>
    </section>

    <section class="slide">
        <h3>Récursivité structurelle : les naturels IV</h3>
    
        <p>Exemple : </p>

        <div class="columns two">
            <div>
                <pre class=""><code class="language-scheme">(define mult
  (lambda (n u)
    (if (zero? n)
        0
        (+ u (mult (- n 1) u)))))</code></pre>
           <pre class="input next"><code class="language-scheme">&gt; (mult 5 4)</code></pre>
           <pre class="output next"><code class="language-">20</code></pre>
        </div>
           <div>
                <pre class="next"><code class="language-scheme">(define F
  (lambda (n u)
    (if (zero? n)
        (G u)
        (H (F (- n 1) (K n u))
           n 
           u))))</code></pre> 
                <pre class="next"><code class="language-scheme">(define G (lambda (u) 0))</code></pre>       
                <pre class="next"><code class="language-scheme">(define K (lambda (n u) u))</code></pre>       
                <pre class="next"><code class="language-scheme">(define H
  (lambda (x n u)
    (+ u x)))</code></pre>       
            </div>
        </div>
    </section>

    <section class="slide">
        <h3>Récursivité structurelle : les naturels V</h3>
    
        <p>Exemple : </p>
    
        <pre class=""><code class="language-scheme">(define fact
  (lambda (n)
    (if (zero? n)
        1
        (* n (fact (- n 1))))))</code></pre>
        <pre class="input next"><code class="language-scheme">&gt; (fact 5)</code></pre>
        <pre class="output next"><code class="language-">120</code></pre>
    </section>


    <section class="slide">
        <h3>Récursivité structurelle : les naturels VI</h3>
    
        <p>Exemple : </p>
    
        <pre class=""><code class="language-scheme">(define cbin
  (lambda (n u)
    (if (zero? n)
        1
        (/ (* (cbin (- n 1) (- u 1)) u) n))))</code></pre>

        <p class="note next">Attention au noms des variables : <code class="language-scheme">(cbin n u)</code> à 
            $\binom{u}{n} = \frac{u!}{n!(u-n)!} = \prod_{i=1}^{n}\frac{u+1-i}{i}$</p>

        <pre class="input next"><code class="language-scheme">&gt; (cbin 3 4)</code></pre>
        <pre class="output next"><code class="language-">4</code></pre>
    </section>

    <section class="slide">
        <h3>Récursivité structurelle : les naturels VII</h3>
    
        <p>Les schémas sont d'abord des schémas de pensée ; ils suggèrent d'exprimer $f(n)$ en termes d'expressions indépendantes de f, mais aussi
            de $f(n - 1)$, si $n \gt 0$. Les schémas imposent en outre la syntaxe du programme : le programmeur doit seulement
            définir les fonctions <code>G</code>, <code>H</code> et <code>K</code>.</p>
        <p>Exemple : </p>
    
        <pre class=""><code class="language-scheme">(define cbin
  (lambda (n u)
    (if (zero? n)
        1
        (/ (* (cbin (- n 1) (- u 1)) u) n))))</code></pre>

        <p>...</p>
    </section>

    <section class="slide">
        <h3>Récursivité structurelle : les naturels VIII</h3>
    
        <pre class=""><code class="language-scheme">; (define cbin
;  (lambda (n u)
;    (if (zero? n)
;        1
;        (/ (* (cbin (- n 1) (- u 1)) u) n))))</code></pre>
        <pre class="next"><code class="language-scheme">(define F
  (lambda (n u)
    (if (zero? n)
        (G u)
        (H (F (- n 1) (K n u)) n u))))</code></pre> 
        <pre class="next"><code class="language-scheme">(define G (lambda (u) 1))</code></pre>       
        <pre class="next"><code class="language-scheme">(define K (lambda (n u) (- u 1)))</code></pre>       
        <pre class="next"><code class="language-scheme">(define H (lambda (r n u) (/ (* r u) n)))</code></pre> 
        <pre class="next"><code class="language-scheme">(define cbin F)</code></pre>     
    </section>

    <section class="slide">
        <h3>Listes : représentation arborescente</h3>
        
        <p>Il existe une correspondance naturelle entre les listes et les arbres. Chaque nœud de l'arbre a un nombre fini
            quelconque de fils.</p>
        
        <div><img src="./chapter-06/tree-1.png" width="60%" alt="Représentation arborescente de l'expression (a (b c d) ((e f) g))." /></div>
        
        <p>ATTENTION ! Cette représentation commode des listes <strong>n'est pas</strong> celle employée en machine !</p>
        
        <p>Remarque. Un arbre réduit à sa racine et étiqueté par un symbole atomique ne sera pas représenté par une liste
            mais par ce symbole.</p>
        
            <p>Remarque. Conceptuellement, seuls les nœuds terminaux de l'arbre représenté ici sont étiquetés ; les étiquettes
            attachées aux nœuds internes sont synthétisées à partir des étiquettes des nœuds successeurs.
            <strong>Les arbres dont les nœuds internes sont étiquetés (indépendamment des feuilles) forment un autre type de
                données.</strong></p>
    </section>

    <section class="slide">
        <h3>Listes : récursivité superficielle I</h3>
    
        <p>[[<code>l</code>]] est soit <code>()</code>, soit [[<code class="language-scheme">(cons (car l) (cdr l))</code>]].</p>
    
        <p>Toute liste s'obtient à partir de <code>()</code> et de <code>cons</code> ;
            la règle de construction est simple : ([[a1]] [[a2]] ... [[an]])
            s'obtient en évaluant <br /> <code class="language-scheme">(cons a1 (cons a2 (cons ... (cons an '()) ...)))</code></p>
    
        <p>Schéma de base :</p>

        <div class="columns two">
            <div class="next">
                <pre class=""><code class="language-scheme">(define F
  (lambda (l u)
    (if (null? l)
        (G u)
        (H (F (cdr l) (K l u))
           l
           u))))</code></pre>
            </div>
            <div>
                <p class="next">Les fonctions <code>G</code>, <code>H</code> et <code>K</code> sont supposées déjà définies ; <code>u</code> représente une suite de 0, 1 ou plusieurs arguments.</p>

                <p class="next">Calculer <code class="language-scheme">(F '() u)</code> n'implique pas d'appel récursif.</p>

                <p class="next">Calculer <code class="language-scheme">(F l u)</code> implique l'appel <code class="language-scheme">(F (cdr l) (K l u))</code> si <code>l</code> n'est pas vide.</p>
            </div>
        </div>    
    </section>

    <section class="slide">
        <h3>Listes : récursivité superficielle II</h3>
    
        <p>Le cas où $|u| = 0$ suffit souvent :</p>

        <pre class=""><code class="language-scheme">(define F
  (lambda (l)
    (if (null? l)
        c
        (H (F (cdr l))
           l))))</code></pre>
    </section>

    <section class="slide">
        <h3>Listes : récursivité superficielle III</h3>
    
        <pre class=""><code class="language-scheme">(define length
  (lambda (l)
    (if (null? l) 0 (+ 1 (length (cdr l))))))</code></pre>
          
        <pre class="input next"><code class="language-scheme">&gt; (length '(f o o bar))</code></pre>
        <pre class="output next"><code class="language-">4</code></pre>

        <pre class="next"><code class="language-scheme">(define append
  (lambda (l v)
    (if (null? l) v (cons (car l) (append (cdr l) v)))))</code></pre>
                    
        <pre class="input next"><code class="language-scheme">&gt; (append '(f o o) '(bar))</code></pre>
        <pre class="output next"><code class="language-">(f o o bar)</code></pre>
    </section>

    <section class="slide">
        <h3>Listes : récursivité superficielle IV</h3>
    
        <pre class=""><code class="language-scheme">(define reverse
  (lambda (l)
    (if (null? l) '() (append (reverse (cdr l)) (list (car l))))))</code></pre>
          
        <pre class="input next"><code class="language-scheme">&gt; (reverse '(f o o bar))</code></pre>
        <pre class="output next"><code class="language-">(bar o o f)</code></pre>

        <pre class="next"><code class="language-scheme">(define map
  (lambda (f l)
    (if (null? l) '() (cons (f (car l)) (map f (cdr l))))))</code></pre>
                    
        <pre class="input next"><code class="language-scheme">&gt; (map (lambda (x) (* x x)) '(1 2 3 4 5 6))</code></pre>
        <pre class="output next"><code class="language-">(1 4 9 16 25 36)</code></pre>
    </section>

    <section class="slide">
        <h3>Listes : récursivité superficielle V</h3>

        <pre class=""><code class="language-scheme">(define map
  (lambda (f l)
    (if (null? l) '() (cons (f (car l)) (map f (cdr l))))))</code></pre>

        <p>s'obtient en instanciant le schéma</p>

        <div class="columns two">
            <div>
                <pre class="next"><code class="language-scheme">(define F
  (lambda (l u)
    (if (null? l)
      (G u)
      (H (F (cdr l) (K l u))
         l
         u))))</code></pre>
            </div>
            <div>
                <pre class="next"><code class="language-scheme">(define G (lambda (u) '()))</code></pre>       
                <pre class="next"><code class="language-scheme">(define K (lambda (l u) u))</code></pre>       
                <pre class="next"><code class="language-scheme">(define H 
  (lambda (r l u) 
    (cons (u (car l)) r)))</code></pre> 
                <pre class="next"><code class="language-scheme">(define map 
  (lambda (f l) (F l f)))</code></pre>     
            </div>
        </div>
    </section>

    <section class="slide">
        <h3>Retournement superficiel ("reverse")</h3>

        <pre class=""><code class="language-scheme">(define reverse
  (lambda (l)
    (if (null? l) '() (append (reverse (cdr l)) (list (car l))))))</code></pre>

        <br />

        <p>L'appel récursif porte sur le <code>cdr</code> seul.</p>

        <pre class="input next"><code class="language-scheme">&gt; (reverse '(a (b c d) ((e f) g)))</code></pre>
        <pre class="output next"><code class="language-">(((e f) g) (b c d) a)</code></pre>

        <div class="next columns two">
            <div>
                <p>Argument :</p>
                <img src="./chapter-06/tree-1.png" width="100%" alt="Représentation arborescente de l'expression (a (b c d) ((e f) g))." />
            </div>
            <div>
                <p>Résultat :</p>
                <img src="./chapter-06/tree-2.png" width="100%" alt="Représentation arborescente de l'expression (((e f) g) (b c d) a)." />
            </div>
        </div>
    </section>

    <section class="slide">
        <h3>Tri par insertion I</h3>

        <pre class=""><code class="language-scheme">(define insert
  (lambda (x l comp) ;; comp est un argument procédural
    (cond ((null? l) (list x))
          ((comp x (car l)) (cons x l))
          (else (cons (car l) (insert x (cdr l) comp))))))</code></pre>

        <pre class="input next"><code class="language-scheme">&gt; (insert 3 '(0 2 3 3 5 7 8 9) &lt;)</code></pre>
        <pre class="output next"><code class="language-">(0 2 3 3 3 5 7 8 9)</code></pre>

        <p class="next">Où ce "3" a-t-il été inséré ?</p>
    </section>

    <section class="slide">
        <h3>Tri par insertion II</h3>

        <pre class=""><code class="language-scheme">(define sort
  (lambda (l comp) ;; comp est un argument procédural
    (if (null? l)
        l
        (insert (car l) (sort (cdr l) comp) comp))))</code></pre>

        <pre class="input next"><code class="language-scheme">&gt; (sort '(8 3 5 7 2 3 9 0) &lt;=)</code></pre>
        <pre class="output next"><code class="language-">(0 2 3 3 5 7 8 9)</code></pre>
        <pre class="input next"><code class="language-scheme">&gt; (sort '(8 3 5 7 2 3 9 0) &gt;=)</code></pre>
        <pre class="output next"><code class="language-">(9 8 7 5 3 3 2 0)</code></pre>
    </section>

    <section class="slide">
        <h3>Tri par insertion III</h3>

        <sub>
            <pre class=""><code class="language-scheme">; (define insert
;   (lambda (x l comp) ;; comp est un argument procédural
;     (cond ((null? l) (list x))
;           ((comp x (car l)) (cons x l))
;           (else (cons (car l) (insert x (cdr l) comp))))))</code></pre>
            
            <pre class=""><code class="language-scheme">(define F
  (lambda (l u1 u2)
    (if (null? l)
        (G u1 u2)
        (H (F (cdr l) (K1 l u1 u2) (K2 l u1 u2)) l u1 u2))))</code></pre>
            
            <pre class="next"><code class="language-scheme">(define G (lambda (u1 u2) (list u1)))</code></pre>
            <pre class="next"><code class="language-scheme">(define H (lambda (r l u1 u2) (if (u2 u1 (car l)) (cons u1 l) (cons (car l) r))))</code></pre>
            <pre class="next"><code class="language-scheme">(define K1 (lambda (l u1 u2) u1))</code></pre>
            <pre class="next"><code class="language-scheme">(define K2 (lambda (l u1 u2) u2))</code></pre>
            <pre class="next"><code class="language-scheme">(define insert (lambda (x l comp) (F l x comp)))</code></pre>
        </sub>
    </section>

    <section class="slide">
        <h3>Tri par insertion IV</h3>

        <sub>
            <pre class=""><code class="language-scheme">; (define sort
;   (lambda (l comp) ;; comp est un argument procédural
;     (if (null? l)
;         l
;         (insert (car l) (sort (cdr l) comp) comp))))</code></pre>
            
            <pre class=""><code class="language-scheme">(define F
  (lambda (l u)
    (if (null? l)
        (G u)
        (H (F (cdr l) (K l u)) l u))))</code></pre>
            
            <pre class="next"><code class="language-scheme">(define G (lambda (u) '()))</code></pre>
            <pre class="next"><code class="language-scheme">(define H (lambda (r l u) (insert (car l) r u)))</code></pre>
            <pre class="next"><code class="language-scheme">(define K (lambda (l u) u))</code></pre>
            <pre class="next"><code class="language-scheme">(define sort (lambda (l comp) (F l comp)))</code></pre>
        </sub>
    </section>

    <section class="slide">
        <h3>Tri par insertion (ordre lexicographique) - I</h3>

        <pre class="input"><code class="language-scheme">&gt; (sort '("bb" "ac" "bc" "acb") string&lt;=?)</code></pre>
        <pre class="output next"><code class="language-">("ac" "acb" "bb" "bc")</code></pre>
    </section>

    <section class="slide">
        <h3>Tri par insertion (ordre lexicographique) - II</h3>

        <pre class="next"><code class="language-scheme">(define lex
  (lambda(str-ord iden) ;; arguments procéduraux
    (lambda (u v)
    (cond ((null? u) #t)
          ((null? v) #f)
          ((str-ord (car u) (car v)) #t)
          ((iden (car u) (car v)) ((lex str-ord iden) (cdr u) (cdr v)))
          (else #f)))))</code></pre>

        <pre class="next"><code class="language-scheme">(define numlex (lex &lt; =))</code></pre>
        <pre class="next"><code class="language-scheme">(define alpha (lex string&lt;? string=?))</code></pre>

        <pre class="input next"><code class="language-scheme">&gt; (sort '((2 3) (1 4) (2 3 2) (1 3)) numlex)</code></pre>
        <pre class="output next"><code class="language-">((1 3) (1 4) (2 3) (2 3 2))</code></pre>

        <pre class="input next"><code class="language-scheme">&gt; (sort '(("acb" "ac") ("ac" "acb") ("ac")) alpha)</code></pre>
        <pre class="output next"><code class="language-">(("ac") ("ac" "acb") ("acb" "ac"))</code></pre>
    </section>

    <section class="slide">
        <h3>Récursivité profonde sur les listes I</h3>

        <div class="columns two">
            <div>
                <p>Schéma de base :</p>
                <sub><pre class=""><code class="language-scheme">(define F
  (lambda (l u)
    (cond ((null? l) (G u))
          ((atom? (car l))
           (H (F (cdr l) (K l u))
              l
              u))
          ((list? (car l))
           (J (F (car l) (Ka l u))
              (F (cdr l) (Kd l u))
              l
              u)))))</code></pre></sub>
            </div>
            <div>
                <p>Schéma simplifié :</p>
                <sub><pre class=""><code class="language-scheme">(define F
  (lambda (l)
    (cond ((null? l) c)
          ((atom? (car l))
           (H (F (cdr l)) l))
          ((list? (car l))
           (J (F (car l))
              (F (cdr l))
              l)))))</code></pre></sub>
            </div>
        </div>
        <br />
        <p>Remarque. On exclut (provisoirement) de rencontrer dans la liste <code>l</code> des objets qui ne soient ni des listes ni des atomes.</p>
    </section>

    <section class="slide">
        <h3>Récursivité profonde sur les listes II</h3>

        <sub>
            <div class="columns two">
                <div>
                    <pre class=""><code class="language-scheme">(define flat-l
  (lambda (l)
    (cond ((null? l) '())
          ((atom? (car l))
           (if (null? (car l))
               (flat-l (cdr l))
               (cons (car l)
                     (flat-l (cdr l)))))
          ((list? (car l))
           (append (flat-l (car l))
                   (flat-l (cdr l)))))))</code></pre>
                </div>
                <div>
                    <p>Attention ! En Racket, la fonction <code>atom?</code> n'existe pas. </p>
                    <p>Vous pouvez le définir en tant que :</p>
                    <br />
                    <pre class=""><code class="language-scheme">(define atom?
  (lambda (x)
    (and (not (null? x))
         (not (pair? x)))))</code></pre>
                </div>
            </div>

            <pre class="input next"><code class="language-scheme">&gt; (flat-l 5)</code></pre>
            <pre class="error next"><code class="language-scheme">car: contract violation
 expected: pair?
 given: 5</code></pre>
            <pre class="input next"><code class="language-scheme">&gt; (flat-l '())</code></pre>
            <pre class="output next"><code class="language-scheme">()</code></pre>
            <pre class="input next"><code class="language-scheme">&gt; (flat-l '(0 (1 2) ((((3))) 4) 5))</code></pre>
            <pre class="output next"><code class="language-scheme">(0 1 2 3 4 5)</code></pre>
        </sub>
    </section>

    <section class="slide">
        <h3>Récursivité profonde sur les listes III</h3>

        <p>Les listes ont pour éléments des objets d'un certain type (par exemple, des atomes) et aussi d'autres listes. On peut
            décider d'adjoindre à ce domaine celui des objets (atomes). Cela revient à admettre les arbres réduits à une
            racine (qui est en même temps l'unique feuille).
            Les schémas précédents s'adaptent facilement.</p>
        <sub>
            <div class="columns two">
                <div>
                    <pre class=""><code class="language-scheme">(define F
  (lambda (l)
    (cond ((null? l) c)
          ((atom? (car l))
           (H (F (cdr l)) l))
          ((list? (car l))
           (J (F (car l))
              (F (cdr l))
              l)))))</code></pre>
                </div>
                <div class="next">
                    <pre class=""><code class="language-scheme">(define F
  (lambda (l)
    (cond ((null? l) c)
          ((atom? l)
           (G l))
          ((list? l)
           (J (F (car l))
              (F (cdr l))
              l)))))</code></pre>
                </div>
            </div>
        </sub>
        <br />
        <p class="next">Remarque. Le remplacement de <code>list?</code> par <code>pair?</code> améliore l'efficacité.</p>
    </section>

    <section class="slide">
        <h3>Récursivité profonde sur les listes IV</h3>

        <pre class=""><code class="language-scheme">(define flat-le
  (lambda (l)
    (cond ((null? l) '())
          ((atom? l) (list l))
          ((list? l) (append (flat-le (car l)) (flat-le (cdr l)))))))</code></pre>

        <pre class="input next"><code class="language-scheme">&gt; (flat-le 5)</code></pre>
        <pre class="output next"><code class="language-scheme">(5)</code></pre>
        <pre class="input next"><code class="language-scheme">&gt; (flat-le '())</code></pre>
        <pre class="output next"><code class="language-scheme">()</code></pre>
        <pre class="input next"><code class="language-scheme">&gt; (flat-le '(0 (1 2) ((((3))) 4) 5))</code></pre>
        <pre class="output next"><code class="language-scheme">(0 1 2 3 4 5)</code></pre>
    </section>

    <section class="slide">
        <h3>Retournement profond ("<code>deeprev</code>")</h3>

        <pre class=""><code class="language-scheme">(define deeprev
  (lambda (l)
    (cond ((null? l) '())
          ((atom? l) l)
          ((list? l)
           (append (deeprev (cdr l))
                   (list (deeprev (car l))))))))</code></pre>
        <br />
        <p>L'appel récursif porte sur le <code>car</code> et le <code>cdr</code>.</p>
    </section>

    <section class="slide">
        <p>Argument :</p>
        <img src="./chapter-06/tree-3.png" width="100%" alt="Représentation arborescente de '(a (b c d) ((e f) g))." />
        <p>Résultat :</p>
        <img src="./chapter-06/tree-4.png" width="100%" alt="Représentation arborescente de '((g (f e)) (d c b) a)." />
    </section>

    <section class="slide">
        <h3>Remarque sur les schémas</h3>

        <p>Suivre un schéma "à la lettre", c'est-à-dire se limiter strictement à instancier les paramètres qu'il contient, rend
            la programmation particulièrement méthodique et sûre. <br />On peut cependant, pour diverses raisons, garder "l'esprit" d'un schéma sans respecter la lettre (sa syntaxe
            précise). Un exemple classique est le programme <code>flatten</code>, version équivalente mais plus 
            efficace de <code>flat-le</code> :</p>

        <pre class=""><code class="language-scheme">(define flatten
  (lambda (l u)
    (cond ((null? l) u)
          ((atom? l) (cons l u))
          ((list? l) (flatten (car l) (flatten (cdr l) u))))))</code></pre>

        <p>On montre facilement que les valeurs de <code class="language-scheme">(flatten l u)</code> et de
            <br /><code class="language-scheme">(append (flat-le l) u)</code> sont égales pour toutes listes <code>l</code> et <code>u</code> ; 
            en particulier, <code class="language-scheme">(flatten l '())</code> et 
            <code class="language-scheme">(flat-le l)</code> ont même
            valeur. Par contre, flatten n'est pas une instance du schéma, même s'il s'en inspire nettement.</p>
        
        <p>On concilie méthode, discipline et créativité...</p>
    </section>

    <section class="slide">
        <h3>Récursivité structurelle généralisée I</h3>
    
        <p>Le principe de la récursivité structurelle est que la structure du programme 
            est calquée sur celle des données.</p>
    
        <p>Exprimer $f(x,...)$ en termes de $\{f(y,...) : y \prec x\}$ <br />
            où $y \prec x$ signifie $y$ composant de $x$.</p>
    
        <p>On peut généraliser :</p>
    
        <ul>
            <li>
                Admettre aussi les composants non immédiats :
                <ul>
                    <li><code>(- n 1)</code>, mais aussi <code>(- n 2)</code>, <code>(/ n 2)</code>,...</li>
                    <li><code>(cdr l)</code>, mais aussi <code>(cddr l)</code>,...</li>
                </ul>
            </li>
            <li>Admettre plusieurs appels récursifs.</li>
            <li>Admettre les appels imbriqués.</li>
        </ul>
        <p>La terminaison reste garantie mais pas l'efficacité !</p>
    </section>

    <section class="slide">
        <h3>Récursivité structurelle généralisée II</h3>
    
        <p>Attention aux erreurs grossières, telles les évaluations de <code>(f (- n 2))</code> avec $n \leq 1$, et de
            <code>(f (cddr l))</code> où l comporte moins de deux éléments.</p>
    
        <pre class="next"><code class="language-scheme">(define fib 
  (lambda (n)
    (if (&lt; n 2) 
        n
        (+ (fib (- n 1)) (fib (- n 2))))))</code></pre>

        <p class="next">Pour quoi est-ce que <code>fib</code> est inefficace ?</p>
    
        <pre class="next"><code class="language-scheme">(define exp
  (lambda (m n)
    (cond ((zero? n) 1)
          ((even? n) (exp (* m m) (/ n 2)))
          ((odd? n) (* m (exp m (- n 1)))))))</code></pre>

          <p class="next">Pour quoi est-ce que <code>exp</code> est très efficace ?</p>
    </section>

    <section class="slide">
        <h3>Récursivité structurelle mixte</h3>
    
        <p>Le principe de la récursivité structurelle est : Exprimer $f(x,...)$ en termes de $\{f(y,...) : y \prec x\}$ ;
            l'induction porte sur un seul argument.</p>

        <p>Le principe de la récursivité structurelle mixte est : Exprimer $f(x_1,x_2,...)$ en termes de
            $\{f(y_1,x_2,...),f(x_1,y_2,...),f(y_1,y_2,...) : y_1 \prec x_1 \wedge y_2 \prec x_2\}$. L'induction porte sur plusieurs
            arguments; si $f(a,b)$ dépend de $f(c,d)$, alors $c \prec a \wedge d \preceq b$ ou $c \preceq a \wedge d \prec b$.</p>

        <p>La terminaison reste garantie.</p>

        <pre class=""><code class="language-scheme">(define gcd
  (lambda (x y)
    (cond ((= x y) x)
          ((&gt; x y) (gcd (- x y) y))
          ((&lt; x y) (gcd x (- y x))))))</code></pre>

        <p>Exemples classiques (voir plus loin) : knapsack, money change,...</p>
    </section>

    <section class="slide">
        <h3>Séparation fonctionnelle I</h3>
    
        <p><sub>
            On peut “dérécursiver” le schéma classique
                $fact(n) := \text{if n = 0 then 1 else } n \times fact(n - 1)$ en l'écriture
                $fact_m(n) := \text{if n = 0 then 1 else } n \times fact_{m-1}(n-1)$. <br />
                La récursivité revient (sous forme dégénérée) pour définir globalement les fonctions $fact_m$ :
        </sub></p>
    
        <pre class="next"><code class="language-scheme">(define f
  (lambda (m c)
    (if (zero? m)
        c
        (f (- m 1) (lambda (n) (if (= n 0) 1 (* n (c (- n 1)))))))))</code></pre>

        <p class="next specification">Si [[<code>m</code>]] = $m$ et [[<code>c</code>]] = $fact_p$, alors
            [[<code>(f m c)</code>]] = $fact_{p+m}$</p>

        <pre class="next"><code class="language-scheme">(define fact0 'emptyfunction)
(define fact (lambda (n) ((f (+ n 1) fact0) n)))</code></pre>
          
        <p class="next"><sub>On observe que $fact_m$ a pour domaine $\{0,1,...,m - 1\}$. Sur ce domaine, on a $fact_m(n) = n!$.</sub></p>
    </section>

    <section class="slide">
        <h3>Séparation fonctionnelle II</h3>
    
        <pre class=""><code class="language-scheme">;; Si [[m]] = m et [[c]] = fact_{p}, alors [[(f m c)]] = fact_{p+m}
(define f
  (lambda (m c)
    (if (zero? m)
        c
        (f (- m 1) (lambda (n) (if (= n 0) 1 (* n (c (- n 1)))))))))

(define fact0 'emptyfunction)
(define fact (lambda (n) ((f (+ n 1) fact0) n)))</code></pre>
    </section>

    <section class="slide">
        <h3>Séparation fonctionnelle III</h3>
    
        <p>Exemples :</p>
    
        <pre class="input next"><code class="language-scheme">&gt; (define fact8 (f 8 fact0))</code></pre>
        <pre class="output next"><code class="language-">...</code></pre>
        <pre class="input next"><code class="language-scheme">&gt; (fact8 7)</code></pre>
        <pre class="output next"><code class="language-">5040</code></pre>
        <pre class="input next"><code class="language-scheme">&gt; (fact8 8)</code></pre>
        <pre class="error next"><code class="language-">application: not a procedure;
expected a procedure that can be applied to arguments
given: emptyfunction</code></pre>
        <pre class="input next"><code class="language-scheme">&gt; (fact 8)</code></pre>
        <pre class="output next"><code class="language-">40320</code></pre>
    </section>

    <section class="slide">
        <h3>Séparation fonctionnelle IV</h3>
    
        <p>On a séparé</p>
        <ul>
            <li>le <em>calcul</em> de la fonction $fact_p$</li>
            <li>l'<em>application</em> de cette fonction à un argument. On a $fact(n) = fact_p(n)$ si $p \gt n$; on choisit $p = n+1$.</li>
        </ul>
    
        <p>Cette technique de séparation fonctionnelle n'apporte rien dans le cas très simple de la fonction factorielle
            mais, dans le cadre général de la définition récursive de fonctions, cette technique sera parfois très
            utile !</p>
    
        <p>Plus généralement, l'introduction de paramètres fonctionnels et/ou de fonctionnelles auxiliaires définies
            récursivement est une technique importante.</p>
    </section>

    <section class="slide">
        <h3>Séparation fonctionnelle V - Processus de calcul</h3>
    
        <sub><pre class=""><code class="language-scheme">(define fact (lambda (n) ((f (+ n 1) fact0) n)))
(define f
  (lambda (m c)
    (if (zero? m)
        c
        (f (- m 1) (lambda (n) (if (= n 0) 1 (* n (c (- n 1)))))))))

(fact 8)
((f 9 fact0) 8)
((f 8 (lambda (n) (if (= n 0) 1 (* n (fact0 (- n 1)))))) 8)
((f 8 fact1) 8)
...
((f 0 fact9) 8)
(fact9 8)
(* 8 (* ... 1))
...
(* 8 5040)
40320</code></pre></sub>
        <p>L'expansion fonctionnelle précède le calcul arithmétique.</p>
    </section>

    <section class="slide">
        <h3>Séparation fonctionnelle VI</h3>
    
        <p>Double comptage :</p>
        <pre class="input"><code class="language-scheme">&gt; (count '(a b a c d a c) 'a)</code></pre>
        <pre class="output"><code class="language-">(3 . 4)</code></pre>
        <p>3 occurrences de "a", 4 autres occurrences.</p>

        <div class="next">
            <p>Solution simple : utiliser deux fonctions auxiliaires.</p>
            <pre class=""><code class="language-scheme">(define count0 (lambda (l s) (cons (c-eq l s) (c-dis l s))))</code></pre>
        </div>

        <p class="next">Problème : on parcourt la liste <code>l</code> deux fois.</p>
    </section>

    <section class="slide">
        <h3>Séparation fonctionnelle VII</h3>
    
        <p>Solution naïve : utiliser le schéma habituel.</p>
        <sub><pre class=""><code class="language-scheme">(define count1
  (lambda (l s)
    (if (null? l)
        (cons 0 0)
        (if (eq? (car l) s)
            (cons (1+ (car (count1 (cdr l) s))) (cdr (count1 (cdr l) s)))
            (cons (car (count1 (cdr l) s)) (1+ (cdr (count1 (cdr l) s))))))))</code></pre></sub>

        <br />
        
        <p>L'inefficacité est catastrophique, mais on peut y remédier simplement.</p>
    </section>

    <section class="slide">
        <h3>Séparation fonctionnelle VIII</h3>
    
        <p>La séparation fonctionnelle est une solution possible :</p>
        <sub><pre class=""><code class="language-scheme">(define c2 ;; écrire une spécification ! 
  (lambda (l s c)
    (if (null? l)
        c
        (if (eq? (car l) s)
            (c2 (cdr l) s (lambda (u) (c (cons (1+ (car u)) (cdr u)))))
            (c2 (cdr l) s (lambda (u) (c (cons (car u) (1+ (cdr u))))))))))
        
(define id (lambda (v) v))
(define count2 (lambda (l s) ((c2 l s id) '(0 . 0))))</code></pre></sub>

        <br />
        
        <p>Si $l$ est la longueur de la liste <code>l</code>, les temps d'exécution 
            de <code>(count0 l)</code> et de <code>(count2 l)</code> sont proportionnels 
            à $l$ ; celui de <code>(count1 l)</code> est proportionnel à $2^l$.</p>

        <p>(On verra d'autres solutions pour ce probl`eme plus loin.)</p>
    </section>

    <section class="slide">
        <h3>Séparation fonctionnelle IX</h3>
    
        <p>Spécification de <code>c2</code> : </p>
        <sub><pre class=""><code class="language-scheme">(define (cx p1) ;; uniquement pour faciliter la sp ́ecification
  (lambda (p2) (cons (+ (car p1) (car p2)) (+ (cdr p1) (cdr p2)))))</code></pre></sub>

        <br />

        <p class="next specification">Si [[<code>(count2 l s)</code>]] = [[<code>(cons a b)</code>]], <br />
            alors [[<code>(c2 l s (cx (cons u v)))</code>]] = [[<code>(cx (cons (+ u a) (+ v b)))</code>]]</p>

        <sub><pre class="next "><code class="language-scheme">;; Si [[(count2 l s)]] = [[(cons a b)]],
;; alors [[(c2 l s (cx (cons u v)))]] = [[(cx (cons (+ u a) (+ v b)))]]
(define c2
  (lambda (l s c)
    (if (null? l)
        c
        (if (eq? (car l) s)
            (c2 (cdr l) s (lambda (u) (c (cons (1+ (car u)) (cdr u)))))
            (c2 (cdr l) s (lambda (u) (c (cons (car u) (1+ (cdr u))))))))))</code></pre></sub>
    </section>

    <section class="slide">
        <h3>Séparation fonctionnelle X</h3>
    
        <p>Produit de liste : $l \to \prod_{x \in l} x$.</p>
        <sub><pre class=""><code class="language-scheme">(define pl1
  (lambda (l)
    (cond ((null? l) 1)
          ((zero? (car l)) 0)
          (else (* (car l) (pl1 (cdr l)))))))</code></pre></sub>

        <br />
        
        <p class="next">Si un facteur est nul, comment éviter toutes les multiplications ? Ici aussi, 
            la séparation fonctionnelle permet une solution.</p>

        <sub><pre class="next"><code class="language-scheme">(define p2 ;; écrire une spécification !
  (lambda (l c)
    (cond ((null? l) c)
          ((zero? (car l)) (lambda (v) 0))
          (else (p2 (cdr l) (lambda (u) (* (car l) (c u))))))))

(define pl2 (lambda (l) ((p2 l id) 1)))</code></pre></sub>

        <br />

        <p class="next">(On verra d'autres solutions pour ce problème plus loin.)</p>
    </section>

    <section class="slide">
        <h3>Séparation fonctionnelle XI</h3>
    
        <p>Spécification de <code>p2</code> : </p>

        <p class="next specification">Si [[<code>l</code>]] est une liste de nombres dont le produit vaut $a$, <br /> 
            et si [[<code>c</code>]] est la fonction $[x \to bx]$, <br />
            alors [[<code>(p2 l c)</code>]] est la fonction $[x \to abx]$.</p>

        <sub><pre class="next "><code class="language-scheme">;; Si [[l]] est une liste de nombres dont le produit vaut a, 
;; et si [[c]] est la fonction [x -&gt; bx],
;; alors [[(p2 l c)]] est la fonction [x -&gt; abx].
(define p2 
  (lambda (l c)
    (cond ((null? l) c)
          ((zero? (car l)) (lambda (v) 0))
          (else (p2 (cdr l) (lambda (u) (* (car l) (c u))))))))</code></pre></sub>
    </section>


    <div class="progress"></div>

    <footer class="badge">
        <p>2021-2022, Christophe Debruyne</p>
    </footer>

    <script src="shower/shower.min.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"
        integrity="sha512-axJX7DJduStuBB8ePC8ryGzacZPr3rdLaIDZitiEgWWk2gsXxEFlm4UW0iNzj2h3wp5mOylgHAzBzM4nRSvTZA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://{{cdn}}/prism@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"
        integrity="sha512-xCfKr8zIONbip3Q1XG/u5x40hoJ0/DtP1bxyMEi0GWzUFoUffE+Dfw1Br8j55RRt9qG7bGKsh+4tSb1CvFHPSA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

</body>

</html>